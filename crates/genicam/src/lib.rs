#![cfg_attr(docsrs, feature(doc_cfg))]
//! High level GenICam facade that re-exports the workspace crates and provides
//! convenience wrappers.
//!
//! ```rust,no_run
//! use genicam::{gige, genapi, Camera, GenicamError};
//! use std::time::Duration;
//!
//! # struct DummyTransport;
//! # impl genapi::RegisterIo for DummyTransport {
//! #     fn read(&self, _addr: u64, len: usize) -> Result<Vec<u8>, genapi::GenApiError> {
//! #         Ok(vec![0; len])
//! #     }
//! #     fn write(&self, _addr: u64, _data: &[u8]) -> Result<(), genapi::GenApiError> {
//! #         Ok(())
//! #     }
//! # }
//! # #[allow(dead_code)]
//! # fn load_nodemap() -> genapi::NodeMap {
//! #     unimplemented!("replace with GenApi XML parsing")
//! # }
//! # #[allow(dead_code)]
//! # async fn open_transport() -> Result<DummyTransport, GenicamError> {
//! #     Ok(DummyTransport)
//! # }
//! # #[allow(dead_code)]
//! # async fn run() -> Result<(), GenicamError> {
//! let timeout = Duration::from_millis(500);
//! let devices = gige::discover(timeout)
//!     .await
//!     .expect("discover cameras");
//! println!("found {} cameras", devices.len());
//! let mut camera = Camera::new(open_transport().await?, load_nodemap());
//! camera.set("ExposureTime", "5000")?;
//! # Ok(())
//! # }
//! ```
//!
//! ```rust,no_run
//! # async fn events_example(
//! #     mut camera: genicam::Camera<genicam::GigeRegisterIo>,
//! # ) -> Result<(), genicam::GenicamError> {
//! use std::net::Ipv4Addr;
//! let ids = ["FrameStart", "ExposureEnd"];
//! let iface = Ipv4Addr::new(127, 0, 0, 1);
//! camera.configure_events(iface, 10020, &ids).await?;
//! let stream = camera.open_event_stream(iface, 10020).await?;
//! let event = stream.next().await?;
//! println!("event id=0x{:04X} payload={} bytes", event.id, event.data.len());
//! # Ok(())
//! # }
//! ```
//!
//! ```rust,no_run
//! # async fn action_example() -> Result<(), std::io::Error> {
//! use genicam::gige::action::{send_action, ActionParams};
//! use std::net::SocketAddr;
//! let params = ActionParams {
//!     device_key: 0,
//!     group_key: 1,
//!     group_mask: 0xFFFF_FFFF,
//!     scheduled_time: None,
//!     channel: 0,
//! };
//! let dest: SocketAddr = "255.255.255.255:3956".parse().unwrap();
//! let summary = send_action(dest, &params, 200).await?;
//! println!("acks={}", summary.acks);
//! Ok(())
//! # }
//! ```

pub use genapi_core as genapi;
pub use genicp;
pub use pfnc;
pub use sfnc;
pub use tl_gige as gige;

pub mod chunks;
pub mod events;
pub mod frame;
pub mod stream;
pub mod time;

use std::net::{IpAddr, Ipv4Addr};
use std::sync::{Arc, Mutex, MutexGuard};
use std::time::{Duration, Instant, SystemTime};

use crate::events::{
    bind_socket as bind_event_socket_internal,
    configure_message_channel_raw as configure_message_channel_fallback,
    enable_event_raw as enable_event_fallback, parse_event_id,
};
use crate::genapi::{GenApiError, Node, NodeMap, RegisterIo, SkOutput};
use gige::gvcp::consts as gvcp_consts;
use gige::GigeDevice;
use thiserror::Error;
use tokio::time::sleep;
use tracing::{debug, info, warn};

pub use chunks::{parse_chunk_bytes, ChunkKind, ChunkMap, ChunkValue};
pub use events::{Event, EventStream};
pub use frame::Frame;
pub use gige::action::{AckSummary, ActionParams};
pub use stream::{Stream, StreamBuilder, StreamDest};
pub use time::TimeSync;

use crate::time::TimeSync as TimeSyncModel;

/// Error type produced by the high level GenICam facade.
#[derive(Debug, Error)]
pub enum GenicamError {
    /// Wrapper around GenApi errors produced by the nodemap.
    #[error(transparent)]
    GenApi(#[from] GenApiError),
    /// Transport level failure while accessing registers.
    #[error("transport: {0}")]
    Transport(String),
    /// Parsing a user supplied value failed.
    #[error("parse error: {0}")]
    Parse(String),
    /// Required chunk feature missing from the nodemap.
    #[error("chunk feature '{0}' not found; verify camera supports chunk data")]
    MissingChunkFeature(String),
    /// The camera reported a pixel format without a conversion path.
    #[error("unsupported pixel format: {0}")]
    UnsupportedPixelFormat(pfnc::PixelFormat),
}

impl GenicamError {
    fn parse<S: Into<String>>(msg: S) -> Self {
        GenicamError::Parse(msg.into())
    }

    fn transport<S: Into<String>>(msg: S) -> Self {
        GenicamError::Transport(msg.into())
    }
}

/// Camera facade combining a nodemap with a transport implementing [`RegisterIo`].
#[derive(Debug)]
pub struct Camera<T: RegisterIo> {
    transport: T,
    nodemap: NodeMap,
    time_sync: TimeSyncModel,
}

impl<T: RegisterIo> Camera<T> {
    /// Create a new camera wrapper from a transport and a nodemap.
    pub fn new(transport: T, nodemap: NodeMap) -> Self {
        Self {
            transport,
            nodemap,
            time_sync: TimeSyncModel::new(64),
        }
    }

    /// Return a reference to the underlying transport.
    pub fn transport(&self) -> &T {
        &self.transport
    }

    /// Return a mutable reference to the underlying transport.
    pub fn transport_mut(&mut self) -> &mut T {
        &mut self.transport
    }

    /// Access the nodemap metadata.
    pub fn nodemap(&self) -> &NodeMap {
        &self.nodemap
    }

    /// Mutable access to the nodemap.
    pub fn nodemap_mut(&mut self) -> &mut NodeMap {
        &mut self.nodemap
    }

    /// List available entries for an enumeration feature.
    pub fn enum_entries(&self, name: &str) -> Result<Vec<String>, GenicamError> {
        self.nodemap.enum_entries(name).map_err(Into::into)
    }

    /// Retrieve a feature value as a string using the nodemap type to format it.
    pub fn get(&self, name: &str) -> Result<String, GenicamError> {
        match self.nodemap.node(name) {
            Some(Node::Integer(_)) => {
                Ok(self.nodemap.get_integer(name, &self.transport)?.to_string())
            }
            Some(Node::Float(_)) => Ok(self.nodemap.get_float(name, &self.transport)?.to_string()),
            Some(Node::Enum(_)) => self
                .nodemap
                .get_enum(name, &self.transport)
                .map_err(Into::into),
            Some(Node::Boolean(_)) => Ok(self.nodemap.get_bool(name, &self.transport)?.to_string()),
            Some(Node::SwissKnife(sk)) => match sk.output {
                SkOutput::Float => Ok(self.nodemap.get_float(name, &self.transport)?.to_string()),
                SkOutput::Integer => {
                    Ok(self.nodemap.get_integer(name, &self.transport)?.to_string())
                }
            },
            Some(Node::Command(_)) => {
                Err(GenicamError::GenApi(GenApiError::Type(name.to_string())))
            }
            Some(Node::Category(_)) => Ok(String::new()),
            None => Err(GenApiError::NodeNotFound(name.to_string()).into()),
        }
    }

    /// Set a feature value using a string representation.
    pub fn set(&mut self, name: &str, value: &str) -> Result<(), GenicamError> {
        match self.nodemap.node(name) {
            Some(Node::Integer(_)) => {
                let parsed: i64 = value
                    .parse()
                    .map_err(|_| GenicamError::parse(format!("invalid integer for {name}")))?;
                self.nodemap
                    .set_integer(name, parsed, &self.transport)
                    .map_err(Into::into)
            }
            Some(Node::Float(_)) => {
                let parsed: f64 = value
                    .parse()
                    .map_err(|_| GenicamError::parse(format!("invalid float for {name}")))?;
                self.nodemap
                    .set_float(name, parsed, &self.transport)
                    .map_err(Into::into)
            }
            Some(Node::Enum(_)) => self
                .nodemap
                .set_enum(name, value, &self.transport)
                .map_err(Into::into),
            Some(Node::Boolean(_)) => {
                let parsed = parse_bool(value).ok_or_else(|| {
                    GenicamError::parse(format!("invalid boolean for {name}: {value}"))
                })?;
                self.nodemap
                    .set_bool(name, parsed, &self.transport)
                    .map_err(Into::into)
            }
            Some(Node::SwissKnife(_)) => Err(GenApiError::Type(name.to_string()).into()),
            Some(Node::Command(_)) => self
                .nodemap
                .exec_command(name, &self.transport)
                .map_err(Into::into),
            Some(Node::Category(_)) => Err(GenApiError::Type(name.to_string()).into()),
            None => Err(GenApiError::NodeNotFound(name.to_string()).into()),
        }
    }

    /// Convenience wrapper for exposure time features expressed in microseconds.
    pub fn set_exposure_time_us(&mut self, value: f64) -> Result<(), GenicamError> {
        // Use SFNC name directly to avoid cross-crate constant lookup issues in docs
        self.set_float_feature("ExposureTime", value)
    }

    /// Convenience wrapper for gain features expressed in decibel.
    pub fn set_gain_db(&mut self, value: f64) -> Result<(), GenicamError> {
        self.set_float_feature("Gain", value)
    }

    fn set_float_feature(&mut self, name: &str, value: f64) -> Result<(), GenicamError> {
        match self.nodemap.node(name) {
            Some(Node::Float(_)) => self
                .nodemap
                .set_float(name, value, &self.transport)
                .map_err(Into::into),
            Some(_) => Err(GenApiError::Type(name.to_string()).into()),
            None => Err(GenApiError::NodeNotFound(name.to_string()).into()),
        }
    }

    /// Capture device/host timestamp pairs and fit a mapping model.
    pub async fn time_calibrate(
        &mut self,
        samples: usize,
        interval_ms: u64,
    ) -> Result<(), GenicamError> {
        if samples < 2 {
            return Err(GenicamError::transport(
                "time calibration requires at least two samples",
            ));
        }

        let cap = samples.max(self.time_sync.capacity());
        self.time_sync = TimeSyncModel::new(cap);

        let latch_cmd = self.find_alias(sfnc::TS_LATCH_CMDS);
        let value_node = self
            .find_alias(sfnc::TS_VALUE_NODES)
            .ok_or_else(|| GenApiError::NodeNotFound("TimestampValue".into()))?;

        let mut freq_hz = if let Some(name) = self.find_alias(sfnc::TS_FREQ_NODES) {
            match self.nodemap.get_integer(name, &self.transport) {
                Ok(value) if value > 0 => Some(value as f64),
                Ok(_) => None,
                Err(err) => {
                    debug!(node = name, error = %err, "failed to read timestamp frequency");
                    None
                }
            }
        } else {
            None
        };

        info!(samples, interval_ms, "starting time calibration");
        let mut first_sample: Option<(u64, Instant)> = None;
        let mut last_sample: Option<(u64, Instant)> = None;

        for idx in 0..samples {
            if let Some(cmd) = latch_cmd {
                self.nodemap
                    .exec_command(cmd, &self.transport)
                    .map_err(GenicamError::from)?;
            }

            let raw_ticks = self
                .nodemap
                .get_integer(value_node, &self.transport)
                .map_err(GenicamError::from)?;
            let dev_ticks = u64::try_from(raw_ticks).map_err(|_| {
                GenicamError::transport("timestamp value is negative; unsupported camera")
            })?;
            let host = Instant::now();
            self.time_sync.update(dev_ticks, host);
            if idx == 0 {
                first_sample = Some((dev_ticks, host));
            }
            last_sample = Some((dev_ticks, host));
            if let Some(origin) = self.time_sync.origin_instant() {
                let ns = host.duration_since(origin).as_nanos();
                debug!(
                    sample = idx,
                    ticks = dev_ticks,
                    host_ns = ns,
                    "timestamp sample"
                );
            } else {
                debug!(sample = idx, ticks = dev_ticks, "timestamp sample");
            }

            if interval_ms > 0 && idx + 1 < samples {
                sleep(Duration::from_millis(interval_ms)).await;
            }
        }

        if freq_hz.is_none() {
            if let (Some((first_ticks, first_host)), Some((last_ticks, last_host))) =
                (first_sample, last_sample)
            {
                if last_ticks > first_ticks {
                    if let Some(delta) = last_host.checked_duration_since(first_host) {
                        let secs = delta.as_secs_f64();
                        if secs > 0.0 {
                            freq_hz = Some((last_ticks - first_ticks) as f64 / secs);
                        }
                    }
                }
            }
        }

        let (a, b) = self
            .time_sync
            .fit(freq_hz)
            .ok_or_else(|| GenicamError::transport("insufficient samples for timestamp fit"))?;

        if let Some(freq) = freq_hz {
            info!(freq_hz = freq, a, b, "time calibration complete");
        } else {
            info!(a, b, "time calibration complete");
        }

        Ok(())
    }

    /// Map device tick counters to host time using the fitted model.
    pub fn map_dev_ts(&self, dev_ticks: u64) -> SystemTime {
        self.time_sync.to_host_time(dev_ticks)
    }

    /// Inspect the timestamp synchroniser state.
    pub fn time_sync(&self) -> &TimeSync {
        &self.time_sync
    }

    /// Reset the device timestamp counter when supported by the camera.
    pub fn time_reset(&mut self) -> Result<(), GenicamError> {
        if let Some(cmd) = self.find_alias(sfnc::TS_RESET_CMDS) {
            self.nodemap
                .exec_command(cmd, &self.transport)
                .map_err(GenicamError::from)?;
            self.time_sync = TimeSyncModel::new(self.time_sync.capacity());
            info!(command = cmd, "timestamp counter reset");
        }
        Ok(())
    }

    /// Trigger acquisition start via the SFNC command feature.
    pub fn acquisition_start(&mut self) -> Result<(), GenicamError> {
        self.nodemap
            .exec_command("AcquisitionStart", &self.transport)
            .map_err(Into::into)
    }

    /// Trigger acquisition stop via the SFNC command feature.
    pub fn acquisition_stop(&mut self) -> Result<(), GenicamError> {
        self.nodemap
            .exec_command("AcquisitionStop", &self.transport)
            .map_err(Into::into)
    }

    /// Configure chunk mode and enable the requested selectors.
    pub fn configure_chunks(&mut self, cfg: &ChunkConfig) -> Result<(), GenicamError> {
        self.ensure_chunk_feature(sfnc::CHUNK_MODE_ACTIVE)?;
        self.ensure_chunk_feature(sfnc::CHUNK_SELECTOR)?;
        self.ensure_chunk_feature(sfnc::CHUNK_ENABLE)?;

        let transport = &self.transport as *const T;
        unsafe {
            // SAFETY: `transport` points to `self.transport`, which is only accessed immutably
            // while the nodemap borrow is active.
            self.nodemap_mut()
                .set_bool(sfnc::CHUNK_MODE_ACTIVE, cfg.active, &*transport)
                .map_err(GenicamError::from)?;
        }

        for selector in &cfg.selectors {
            let transport = &self.transport as *const T;
            unsafe {
                // SAFETY: see rationale above; the nodemap mutation does not alias with
                // the immutable transport access.
                self.nodemap_mut()
                    .set_enum(sfnc::CHUNK_SELECTOR, selector, &*transport)
                    .map_err(GenicamError::from)?;
                self.nodemap_mut()
                    .set_bool(sfnc::CHUNK_ENABLE, true, &*transport)
                    .map_err(GenicamError::from)?;
            }
        }

        Ok(())
    }

    /// Configure the GVCP message channel and enable delivery of the requested events.
    pub async fn configure_events(
        &mut self,
        local_ip: Ipv4Addr,
        port: u16,
        enable_ids: &[&str],
    ) -> Result<(), GenicamError> {
        info!(%local_ip, port, "configuring GVCP events");
        let transport_ptr = &self.transport as *const T;
        let mut channel_configured = true;

        if let Some(selector) = self.find_alias(sfnc::MSG_SEL) {
            match self.nodemap.enum_entries(selector) {
                Ok(entries) => {
                    if let Some(entry) = entries.into_iter().next() {
                        unsafe {
                            self.nodemap_mut()
                                .set_enum(selector, &entry, &*transport_ptr)
                                .map_err(GenicamError::from)?;
                        }
                    } else {
                        warn!(node = selector, "message selector missing entries");
                        channel_configured = false;
                    }
                }
                Err(err) => {
                    warn!(feature = selector, error = %err, "failed to query message selector");
                    channel_configured = false;
                }
            }
        } else {
            channel_configured = false;
        }

        if let Some(node) = self.find_alias(sfnc::MSG_IP) {
            let value = u32::from(local_ip) as i64;
            unsafe {
                if let Err(err) = self.nodemap_mut().set_integer(node, value, &*transport_ptr) {
                    warn!(feature = node, error = %err, "failed to write message IP");
                    channel_configured = false;
                }
            }
        } else {
            channel_configured = false;
        }

        if let Some(node) = self.find_alias(sfnc::MSG_PORT) {
            unsafe {
                if let Err(err) = self
                    .nodemap_mut()
                    .set_integer(node, port as i64, &*transport_ptr)
                {
                    warn!(feature = node, error = %err, "failed to write message port");
                    channel_configured = false;
                }
            }
        } else {
            channel_configured = false;
        }

        if let Some(node) = self.find_alias(sfnc::MSG_EN) {
            unsafe {
                if let Err(err) = self.nodemap_mut().set_bool(node, true, &*transport_ptr) {
                    warn!(feature = node, error = %err, "failed to enable message channel");
                    channel_configured = false;
                }
            }
        } else {
            channel_configured = false;
        }

        if !channel_configured {
            configure_message_channel_fallback(&self.transport, local_ip, port)?;
        }

        let mut used_sfnc = self.nodemap.node(sfnc::EVENT_SELECTOR).is_some()
            && self.nodemap.node(sfnc::EVENT_NOTIFICATION).is_some();

        if used_sfnc {
            for &name in enable_ids {
                unsafe {
                    if let Err(err) =
                        self.nodemap_mut()
                            .set_enum(sfnc::EVENT_SELECTOR, name, &*transport_ptr)
                    {
                        warn!(event = name, error = %err, "failed to select event via SFNC");
                        used_sfnc = false;
                        break;
                    }
                    if let Err(err) = self.nodemap_mut().set_enum(
                        sfnc::EVENT_NOTIFICATION,
                        sfnc::EVENT_NOTIF_ON,
                        &*transport_ptr,
                    ) {
                        warn!(event = name, error = %err, "failed to enable event via SFNC");
                        used_sfnc = false;
                        break;
                    }
                }
            }
        }

        if !used_sfnc {
            for &name in enable_ids {
                let Some(event_id) = parse_event_id(name) else {
                    return Err(GenicamError::transport(format!(
                        "event '{name}' missing from nodemap and not numeric"
                    )));
                };
                enable_event_fallback(&self.transport, event_id, true)?;
            }
        }

        Ok(())
    }

    /// Configure the stream channel for multicast delivery.
    pub fn configure_stream_multicast(
        &mut self,
        stream_idx: u32,
        group: Ipv4Addr,
        port: u16,
    ) -> Result<(), GenicamError> {
        if (group.octets()[0] & 0xF0) != 0xE0 {
            return Err(GenicamError::transport(
                "multicast group must be within 224.0.0.0/4",
            ));
        }
        info!(stream_idx, %group, port, "configuring multicast stream");

        let transport_ptr = &self.transport as *const T;
        let mut used_sfnc = true;

        if self.nodemap.node(sfnc::STREAM_CH_SELECTOR).is_some() {
            unsafe {
                if let Err(err) = self.nodemap_mut().set_integer(
                    sfnc::STREAM_CH_SELECTOR,
                    stream_idx as i64,
                    &*transport_ptr,
                ) {
                    warn!(
                        channel = stream_idx,
                        error = %err,
                        "failed to select stream channel via SFNC"
                    );
                    used_sfnc = false;
                }
            }
        } else {
            used_sfnc = false;
        }

        if let Some(node) = self.find_alias(sfnc::SCP_DEST_ADDR) {
            unsafe {
                if let Err(err) =
                    self.nodemap_mut()
                        .set_integer(node, u32::from(group) as i64, &*transport_ptr)
                {
                    warn!(feature = node, error = %err, "failed to write multicast address");
                    used_sfnc = false;
                }
            }
        } else {
            used_sfnc = false;
        }

        if let Some(node) = self.find_alias(sfnc::SCP_HOST_PORT) {
            unsafe {
                if let Err(err) = self
                    .nodemap_mut()
                    .set_integer(node, port as i64, &*transport_ptr)
                {
                    warn!(feature = node, error = %err, "failed to write multicast port");
                    used_sfnc = false;
                }
            }
        } else {
            used_sfnc = false;
        }

        if let Some(node) = self.find_alias(sfnc::MULTICAST_ENABLE) {
            unsafe {
                if let Err(err) = self.nodemap_mut().set_bool(node, true, &*transport_ptr) {
                    warn!(feature = node, error = %err, "failed to enable multicast flag");
                }
            }
        }

        if !used_sfnc {
            let base = gvcp_consts::STREAM_CHANNEL_BASE
                + stream_idx as u64 * gvcp_consts::STREAM_CHANNEL_STRIDE;
            let addr_reg = base + gvcp_consts::STREAM_DESTINATION_ADDRESS;
            self.transport
                .write(addr_reg, &group.octets())
                .map_err(|err| GenicamError::transport(format!("write multicast addr: {err}")))?;
            let port_reg = base + gvcp_consts::STREAM_DESTINATION_PORT;
            self.transport
                .write(port_reg, &port.to_be_bytes())
                .map_err(|err| GenicamError::transport(format!("write multicast port: {err}")))?;
            info!(
                stream_idx,
                %group,
                port,
                "configured multicast destination via raw registers"
            );
        } else {
            info!(
                stream_idx,
                %group,
                port,
                "configured multicast destination via SFNC"
            );
        }

        Ok(())
    }

    /// Open a GVCP event stream bound to the provided local endpoint.
    pub async fn open_event_stream(
        &self,
        local_ip: Ipv4Addr,
        port: u16,
    ) -> Result<EventStream, GenicamError> {
        let socket = bind_event_socket_internal(IpAddr::V4(local_ip), port).await?;
        let time_sync = if !self.time_sync.is_empty() {
            Some(Arc::new(self.time_sync.clone()))
        } else {
            None
        };
        Ok(EventStream::new(socket, time_sync))
    }

    fn ensure_chunk_feature(&self, name: &str) -> Result<(), GenicamError> {
        if self.nodemap.node(name).is_none() {
            return Err(GenicamError::MissingChunkFeature(name.to_string()));
        }
        Ok(())
    }

    fn find_alias(&self, names: &[&'static str]) -> Option<&'static str> {
        names
            .iter()
            .copied()
            .find(|name| self.nodemap.node(name).is_some())
    }
}

/// Configuration for enabling chunk data via SFNC features.
#[derive(Debug, Clone, Default)]
pub struct ChunkConfig {
    /// Names of chunk selectors that should be enabled on the device.
    pub selectors: Vec<String>,
    /// Whether chunk mode should be active after configuration.
    pub active: bool,
}

/// Blocking adapter turning an asynchronous [`GigeDevice`] into a [`RegisterIo`]
/// implementation.
///
/// The adapter uses a [`tokio::runtime::Handle`] to synchronously wait on GVCP
/// register transactions. All callers must ensure these methods are invoked
/// from outside of the runtime context to avoid nested `block_on` panics.
pub struct GigeRegisterIo {
    handle: tokio::runtime::Handle,
    device: Mutex<GigeDevice>,
}

impl GigeRegisterIo {
    /// Create a new adapter using the provided runtime handle and device.
    pub fn new(handle: tokio::runtime::Handle, device: GigeDevice) -> Self {
        Self {
            handle,
            device: Mutex::new(device),
        }
    }

    fn lock(&self) -> Result<MutexGuard<'_, GigeDevice>, GenApiError> {
        self.device
            .lock()
            .map_err(|_| GenApiError::Io("gige device mutex poisoned".into()))
    }
}

impl RegisterIo for GigeRegisterIo {
    fn read(&self, addr: u64, len: usize) -> Result<Vec<u8>, GenApiError> {
        let mut device = self.lock()?;
        self.handle
            .block_on(device.read_mem(addr, len))
            .map_err(|err| GenApiError::Io(err.to_string()))
    }

    fn write(&self, addr: u64, data: &[u8]) -> Result<(), GenApiError> {
        let mut device = self.lock()?;
        self.handle
            .block_on(device.write_mem(addr, data))
            .map_err(|err| GenApiError::Io(err.to_string()))
    }
}

fn parse_bool(value: &str) -> Option<bool> {
    match value.trim().to_ascii_lowercase().as_str() {
        "1" | "true" => Some(true),
        "0" | "false" => Some(false),
        _ => None,
    }
}
